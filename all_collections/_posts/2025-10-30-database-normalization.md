---
layout: post
title: 🎯 데이터베이스 정규화의 모든 것
date: 2025-10-30
categories: ["SamBeak", "Database", "Normalization", "DB", "설계"]
---

# 데이터베이스 정규화란 무엇인가

<br>
데이터베이스를 설계하다 보면 종종 난감한 상황에 마주하곤 한다. <br>
같은 정보가 여러 곳에 중복되어 저장되거나, <br>
하나의 테이블에 너무 많은 정보가 담겨있어 관리하기 어려운 경우 말이다. <br><br>

이는 마치 책상 서랍을 정리하지 않고 사용하는 것과 비슷하다. <br>
처음엔 편할지 몰라도, 시간이 지날수록 <br>
같은 물건이 여러 서랍에 흩어져있고, <br>
필요한 물건을 찾기 위해 모든 서랍을 뒤져야 하는 상황이 온다. <br><br>

데이터베이스 정규화(Normalization)는 바로 이런 문제를 해결하기 위한 체계적인 방법이다. <br>
데이터의 중복을 최소화하고, 데이터 무결성을 유지하며, <br>
효율적인 데이터 관리를 가능하게 하는 설계 기법이다. <br><br>

> ## 왜 데이터베이스 정규화가 필요할까?

<br>
정규화를 하지 않은 데이터베이스는 여러 문제를 야기한다. <br><br>

첫째, **중복 이상(Redundancy Anomaly)**이 발생한다. <br>
같은 정보가 여러 곳에 저장되어 있으면 데이터를 수정할 때 <br>
모든 위치를 찾아서 수정해야 하는데, <br>
하나라도 누락되면 데이터 불일치가 발생한다. <br><br>

둘째, **삽입 이상(Insertion Anomaly)**이 발생한다. <br>
새로운 데이터를 입력할 때 불필요한 정보까지 함께 입력해야 하거나, <br>
특정 정보 없이는 데이터를 입력할 수 없는 상황이 생긴다. <br><br>

셋째, **삭제 이상(Deletion Anomaly)**이 발생한다. <br>
어떤 정보를 삭제할 때 함께 보관하고 싶은 다른 정보까지 <br>
함께 삭제되는 문제가 발생한다. <br><br>

넷째, **갱신 이상(Update Anomaly)**이 발생한다. <br>
데이터를 수정할 때 일부만 수정되어 <br>
데이터의 일관성이 깨지는 경우가 생긴다. <br><br>

# 정규화의 단계별 이해

<br>
데이터베이스 정규화는 여러 단계로 나뉘어져 있다. <br>
각 단계를 정규형(Normal Form)이라고 부르며, <br>
제1정규형부터 제5정규형까지 존재한다. <br>
실무에서는 보통 제3정규형까지 적용하는 것이 일반적이다. <br><br>

> ## 제1정규형 (1NF: First Normal Form)

<br>
제1정규형은 가장 기본적인 정규화 단계로, <br>
**모든 속성 값이 원자값(Atomic Value)**을 가져야 한다는 규칙이다. <br><br>

쉽게 말해, 하나의 칸에는 하나의 값만 들어가야 한다는 의미다. <br>
배열이나 리스트 같은 복합 값은 허용되지 않는다. <br><br>

**정규화 전 예시:**

| 학생ID | 학생이름 | 수강과목 |
|--------|----------|----------|
| 1 | 김철수 | 수학, 영어, 국어 |
| 2 | 이영희 | 과학, 수학 |

<br>
**제1정규형 적용 후:**

| 학생ID | 학생이름 | 수강과목 |
|--------|----------|----------|
| 1 | 김철수 | 수학 |
| 1 | 김철수 | 영어 |
| 1 | 김철수 | 국어 |
| 2 | 이영희 | 과학 |
| 2 | 이영희 | 수학 |

<br>
이제 각 칸에는 하나의 값만 들어가게 되었다. <br>
단, 이 상태에서는 학생 정보가 중복되는 문제가 있다. <br><br>

> ## 제2정규형 (2NF: Second Normal Form)

<br>
제2정규형은 제1정규형을 만족하면서, <br>
**부분 함수 종속성을 제거**한 상태를 의미한다. <br><br>

부분 함수 종속성이란 기본키의 일부분에만 종속되는 속성을 말한다. <br>
복합키(여러 속성으로 이루어진 기본키)가 있을 때 발생한다. <br><br>

**정규화 전 예시:**

| 학생ID | 과목코드 | 학생이름 | 과목이름 | 성적 |
|--------|----------|----------|----------|------|
| 1 | M01 | 김철수 | 수학 | A |
| 1 | E01 | 김철수 | 영어 | B |
| 2 | M01 | 이영희 | 수학 | A+ |

기본키: (학생ID, 과목코드) <br>
문제: 학생이름은 학생ID에만 종속, 과목이름은 과목코드에만 종속 <br><br>

**제2정규형 적용 후:**

**학생 테이블:**

| 학생ID | 학생이름 |
|--------|----------|
| 1 | 김철수 |
| 2 | 이영희 |

**과목 테이블:**

| 과목코드 | 과목이름 |
|----------|----------|
| M01 | 수학 |
| E01 | 영어 |

**수강 테이블:**

| 학생ID | 과목코드 | 성적 |
|--------|----------|------|
| 1 | M01 | A |
| 1 | E01 | B |
| 2 | M01 | A+ |

<br>
이제 각 정보가 적절한 테이블로 분리되었다. <br><br>

> ## 제3정규형 (3NF: Third Normal Form)

<br>
제3정규형은 제2정규형을 만족하면서, <br>
**이행 함수 종속성을 제거**한 상태를 의미한다. <br><br>

이행 함수 종속성이란 A → B, B → C일 때 A → C가 성립하는 관계를 말한다. <br>
즉, 기본키가 아닌 속성이 다른 비기본키 속성을 결정하는 경우다. <br><br>

**정규화 전 예시:**

| 학생ID | 학생이름 | 학과코드 | 학과이름 | 학과장 |
|--------|----------|----------|----------|--------|
| 1 | 김철수 | CS | 컴퓨터공학 | 박교수 |
| 2 | 이영희 | EE | 전자공학 | 최교수 |
| 3 | 박민수 | CS | 컴퓨터공학 | 박교수 |

기본키: 학생ID <br>
문제: 학생ID → 학과코드 → 학과이름, 학과장 (이행 종속) <br><br>

**제3정규형 적용 후:**

**학생 테이블:**

| 학생ID | 학생이름 | 학과코드 |
|--------|----------|----------|
| 1 | 김철수 | CS |
| 2 | 이영희 | EE |
| 3 | 박민수 | CS |

**학과 테이블:**

| 학과코드 | 학과이름 | 학과장 |
|----------|----------|--------|
| CS | 컴퓨터공학 | 박교수 |
| EE | 전자공학 | 최교수 |

<br>
이제 학과 정보가 중복되지 않고, <br>
학과장이 바뀌어도 한 곳만 수정하면 된다. <br><br>

# 정규화의 장점과 단점

<br>

## 🟢 정규화의 장점

<br>

1. **데이터 중복 최소화** <br>
   같은 데이터를 여러 곳에 저장하지 않아 저장 공간을 절약할 수 있다. <br><br>

2. **데이터 무결성 향상** <br>
   중복이 없으므로 데이터 불일치 문제가 발생하지 않는다. <br><br>

3. **이상 현상 방지** <br>
   삽입, 삭제, 갱신 시 발생할 수 있는 이상 현상을 예방할 수 있다. <br><br>

4. **유지보수 용이** <br>
   데이터 구조가 명확하여 수정이 필요할 때 영향 범위가 명확하다. <br><br>

5. **확장성 향상** <br>
   새로운 데이터 추가 시 기존 구조에 영향을 최소화할 수 있다. <br><br>

## 🔴 정규화의 단점

<br>

1. **조인 연산 증가** <br>
   테이블이 분리되면서 데이터를 조회할 때 여러 테이블을 조인해야 한다. <br><br>

2. **성능 저하 가능성** <br>
   조인 연산이 많아지면 쿼리 성능이 저하될 수 있다. <br><br>

3. **복잡도 증가** <br>
   테이블 수가 많아져 초기 설계와 쿼리 작성이 복잡해질 수 있다. <br><br>

# 반정규화 (Denormalization)

<br>
정규화가 항상 정답은 아니다. <br>
때로는 의도적으로 정규화를 풀어야 하는 경우도 있다. <br><br>

반정규화는 **성능 향상을 위해 의도적으로 중복을 허용**하는 기법이다. <br>
특히 조회 성능이 중요한 시스템에서 자주 사용된다. <br><br>

## 🏷️ 반정규화를 고려해야 하는 경우

<br>

- 조인 연산이 너무 많아 성능이 심각하게 저하되는 경우 <br>
- 특정 테이블의 조회 빈도가 매우 높은 경우 <br>
- 통계나 집계 데이터를 자주 사용하는 경우 <br>
- 이력 데이터를 빠르게 조회해야 하는 경우 <br><br>

단, 반정규화를 적용할 때는 반드시 다음을 고려해야 한다:

1. 데이터 일관성 유지 방안 마련 <br>
2. 트리거나 애플리케이션 로직으로 중복 데이터 동기화 <br>
3. 성능 개선 효과 측정 <br><br>

# 실전 예시: 쇼핑몰 데이터베이스 정규화

<br>
실제 쇼핑몰 데이터베이스를 정규화하는 과정을 살펴보자. <br><br>

**정규화 전:**

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_name VARCHAR(100),
    customer_email VARCHAR(100),
    customer_phone VARCHAR(20),
    product_name VARCHAR(100),
    product_price DECIMAL(10,2),
    quantity INT,
    order_date DATE
);
```

<br>
이 구조는 여러 문제가 있다: <br>
- 고객 정보 중복 <br>
- 상품 정보 중복 <br>
- 한 주문에 여러 상품을 담을 수 없음 <br><br>

**정규화 후 (제3정규형):**

```sql
-- 고객 테이블
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_name VARCHAR(100) NOT NULL,
    customer_email VARCHAR(100) UNIQUE NOT NULL,
    customer_phone VARCHAR(20)
);

-- 상품 테이블
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100) NOT NULL,
    product_price DECIMAL(10,2) NOT NULL,
    stock_quantity INT DEFAULT 0
);

-- 주문 테이블
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10,2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- 주문 상세 테이블
CREATE TABLE order_details (
    order_detail_id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
```

<br>
이제 다음과 같은 이점을 얻을 수 있다: <br>
- 고객 정보는 한 곳에서만 관리 <br>
- 상품 가격 변경 시 한 번만 수정 <br>
- 한 주문에 여러 상품을 담을 수 있음 <br>
- 주문 시점의 가격을 order_details에 저장하여 이력 관리 가능 <br><br>

# 정규화 적용 시 주의사항

<br>

1. **과도한 정규화 지양** <br>
   제3정규형까지만 적용해도 대부분의 경우 충분하다. <br>
   무조건 높은 정규형을 적용하면 오히려 복잡도만 증가한다. <br><br>

2. **비즈니스 요구사항 우선** <br>
   성능이 중요한 곳은 반정규화를 고려해야 한다. <br>
   이론적 완벽함보다 실용성이 중요하다. <br><br>

3. **인덱스 활용** <br>
   정규화로 조인이 많아졌다면 적절한 인덱스를 생성하여 <br>
   성능 저하를 최소화해야 한다. <br><br>

4. **문서화** <br>
   정규화 결과와 테이블 간 관계를 명확히 문서화하여 <br>
   다른 개발자도 쉽게 이해할 수 있도록 한다. <br><br>

# 마무리

<br>
데이터베이스 정규화는 단순히 이론적 개념이 아니라 <br>
실제 프로젝트에서 데이터 품질과 유지보수성을 결정하는 중요한 기법이다. <br><br>

처음 데이터베이스를 설계할 때 정규화를 고려하면 <br>
나중에 발생할 수 있는 많은 문제를 예방할 수 있다. <br>
하지만 맹목적으로 정규화만 추구하기보다는 <br>
프로젝트의 특성과 요구사항을 고려하여 <br>
적절한 수준의 정규화를 적용하는 것이 중요하다. <br><br>

실무 경험을 쌓다 보면 언제 정규화를 적용하고 <br>
언제 반정규화를 고려해야 하는지 감각이 생긴다. <br>
이 글이 그 시작점이 되길 바란다. <br><br>
